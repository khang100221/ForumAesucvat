const {
  EmbedBuilder,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  ModalBuilder,
  TextInputBuilder,
  TextInputStyle,
  PermissionFlagsBits,
  ChannelType,
} = require('discord.js');
const fs = require('fs').promises;
const path = require('path');

const TICKET_ICON = 'https://cdn-icons-png.flaticon.com/512/4332/4332637.png';

// C·∫£i ti·∫øn: S·ª≠ d·ª•ng Map ƒë·ªÉ qu·∫£n l√Ω cooldown t·ªët h∆°n
const ticketCooldowns = new Map();
const COOLDOWN_TIME = 5000; // 5 gi√¢y

// C·∫£i ti·∫øn: Th√™m cache ƒë·ªÉ t·ªëi ∆∞u hi·ªáu su·∫•t
const configCache = new Map();
const CACHE_TTL = 300000; // 5 ph√∫t

// H√†m helper: L·∫•y config v·ªõi cache
function getTicketConfig(db, guildId) {
  const cacheKey = `config_${guildId}`;
  const cached = configCache.get(cacheKey);
  
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.data;
  }
  
  const config = db.prepare('SELECT * FROM ticket_config WHERE guildId = ?').get(guildId) || {};
  configCache.set(cacheKey, { data: config, timestamp: Date.now() });
  return config;
}

// H√†m helper: X√≥a cache config
function clearConfigCache(guildId) {
  configCache.delete(`config_${guildId}`);
}

// H√†m helper: Ki·ªÉm tra cooldown
function checkCooldown(userId, action) {
  const key = `${userId}_${action}`;
  const now = Date.now();
  const lastAction = ticketCooldowns.get(key);
  
  if (lastAction && now - lastAction < COOLDOWN_TIME) {
    return Math.ceil((COOLDOWN_TIME - (now - lastAction)) / 1000);
  }
  
  ticketCooldowns.set(key, now);
  // T·ª± ƒë·ªông x√≥a sau cooldown ƒë·ªÉ tr√°nh memory leak
  setTimeout(() => ticketCooldowns.delete(key), COOLDOWN_TIME);
  return 0;
}

// H√†m helper: Validate permissions
async function validateBotPermissions(guild, categoryId) {
  try {
    const category = guild.channels.cache.get(categoryId);
    if (!category) return { valid: false, error: 'Danh m·ª•c kh√¥ng t·ªìn t·∫°i' };
    
    const botMember = guild.members.me;
    const permissions = botMember.permissionsIn(category);
    
    const requiredPerms = [
      PermissionFlagsBits.ManageChannels,
      PermissionFlagsBits.ViewChannel,
      PermissionFlagsBits.SendMessages,
      PermissionFlagsBits.ManageRoles
    ];
    
    const missingPerms = requiredPerms.filter(perm => !permissions.has(perm));
    
    if (missingPerms.length > 0) {
      return { 
        valid: false, 
        error: `Bot thi·∫øu quy·ªÅn: ${missingPerms.map(p => p.toString()).join(', ')}` 
      };
    }
    
    return { valid: true };
  } catch (error) {
    return { valid: false, error: 'L·ªói khi ki·ªÉm tra quy·ªÅn bot' };
  }
}

// H√†m helper: T·∫°o embed l·ªói
function createErrorEmbed(message, title = '‚ùå L·ªói') {
  return new EmbedBuilder()
    .setColor('#E74C3C')
    .setTitle(title)
    .setDescription(message)
    .setThumbnail(TICKET_ICON)
    .setTimestamp();
}

// H√†m helper: T·∫°o embed th√†nh c√¥ng
function createSuccessEmbed(message, title = '‚úÖ Th√†nh c√¥ng') {
  return new EmbedBuilder()
    .setColor('#43ea3a')
    .setTitle(title)
    .setDescription(message)
    .setThumbnail(TICKET_ICON)
    .setTimestamp();
}

async function handleTicketInteraction(interaction, db) {
  try {
    // --- T·∫†O TICKET ---
    if (interaction.isButton() && interaction.customId === 'ticket_create') {
      // Ki·ªÉm tra cooldown
      const cooldown = checkCooldown(interaction.user.id, 'create_ticket');
      if (cooldown > 0) {
        await interaction.reply({
          embeds: [createErrorEmbed(`‚è≥ Vui l√≤ng ƒë·ª£i ${cooldown} gi√¢y tr∆∞·ªõc khi t·∫°o ticket m·ªõi!`)],
          ephemeral: true
        });
        return true;
      }

      await interaction.deferReply({ ephemeral: true });

      const conf = getTicketConfig(db, interaction.guild.id);
      
      // C·∫£i ti·∫øn: Ki·ªÉm tra setup ƒë·∫ßy ƒë·ªß h∆°n
      if (!conf.category_create) {
        await interaction.editReply({
          embeds: [createErrorEmbed('Ticket ch∆∞a ƒë∆∞·ª£c setup danh m·ª•c t·∫°o! Vui l√≤ng li√™n h·ªá admin ƒë·ªÉ c·∫•u h√¨nh.')]
        });
        return true;
      }

      // C·∫£i ti·∫øn: Validate quy·ªÅn bot chi ti·∫øt h∆°n
      const permCheck = await validateBotPermissions(interaction.guild, conf.category_create);
      if (!permCheck.valid) {
        await interaction.editReply({
          embeds: [createErrorEmbed(permCheck.error)]
        });
        return true;
      }

      // C·∫£i ti·∫øn: Ki·ªÉm tra ticket t·ªìn t·∫°i v·ªõi query t·ªëi ∆∞u h∆°n
      const existingTicket = interaction.guild.channels.cache.find(c =>
        c.parentId === conf.category_create &&
        c.topic && 
        c.topic.includes(`UID:${interaction.user.id}`) &&
        c.topic.startsWith('Ticket:')
      );
      
      if (existingTicket) {
        await interaction.editReply({
          embeds: [new EmbedBuilder()
            .setColor('#FFC107')
            .setTitle('‚ö†Ô∏è Ticket ƒë√£ t·ªìn t·∫°i')
            .setDescription(`B·∫°n ƒë√£ c√≥ ticket ƒëang m·ªü t·∫°i <#${existingTicket.id}>!\nVui l√≤ng ho√†n th√†nh ticket hi·ªán t·∫°i tr∆∞·ªõc khi t·∫°o ticket m·ªõi.`)
            .setThumbnail(TICKET_ICON)
          ]
        });
        return true;
      }

      // C·∫£i ti·∫øn: Transaction ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n
      let ticketCount;
      try {
        const transaction = db.transaction(() => {
          const current = db.prepare('SELECT ticket_count FROM ticket_config WHERE guildId = ?').get(interaction.guild.id);
          const newCount = (current?.ticket_count || 0) + 1;
          
          db.prepare(`
            INSERT INTO ticket_config (guildId, ticket_count) 
            VALUES (?, ?) 
            ON CONFLICT(guildId) DO UPDATE SET ticket_count = ?
          `).run(interaction.guild.id, newCount, newCount);
          
          return newCount;
        });
        
        ticketCount = transaction();
        clearConfigCache(interaction.guild.id); // X√≥a cache sau khi update
      } catch (error) {
        console.error('Database error:', error);
        await interaction.editReply({
          embeds: [createErrorEmbed('L·ªói h·ªá th·ªëng khi t·∫°o ticket! Vui l√≤ng th·ª≠ l·∫°i sau.')]
        });
        return true;
      }

      const channelName = `ticket-${ticketCount.toString().padStart(4, '0')}`;
      const ticketTopic = `Ticket: ${ticketCount} | UID:${interaction.user.id} | Created: ${Date.now()}`;

      // C·∫£i ti·∫øn: X·ª≠ l√Ω role ping th√¥ng minh h∆°n
      let pingRole = conf.admin_role;
      if (!pingRole || !interaction.guild.roles.cache.has(pingRole)) {
        const adminRoles = interaction.guild.roles.cache
          .filter(r => r.id !== interaction.guild.id && r.permissions.has(PermissionFlagsBits.ManageChannels))
          .sort((a, b) => b.position - a.position);
        pingRole = adminRoles.first()?.id;
      }

      // C·∫£i ti·∫øn: T·∫°o channel v·ªõi error handling t·ªët h∆°n
      let ticketChannel;
      try {
        const permissionOverwrites = [
          { 
            id: interaction.guild.roles.everyone, 
            deny: [PermissionFlagsBits.ViewChannel] 
          },
          { 
            id: interaction.user.id, 
            allow: [
              PermissionFlagsBits.ViewChannel, 
              PermissionFlagsBits.SendMessages,
              PermissionFlagsBits.ReadMessageHistory,
              PermissionFlagsBits.AttachFiles
            ] 
          },
          { 
            id: interaction.client.user.id, 
            allow: [
              PermissionFlagsBits.ViewChannel, 
              PermissionFlagsBits.SendMessages,
              PermissionFlagsBits.ManageChannels,
              PermissionFlagsBits.ReadMessageHistory,
              PermissionFlagsBits.AttachFiles,
              PermissionFlagsBits.ManageMessages
            ] 
          }
        ];

        if (pingRole && interaction.guild.roles.cache.has(pingRole)) {
          permissionOverwrites.push({
            id: pingRole,
            allow: [
              PermissionFlagsBits.ViewChannel,
              PermissionFlagsBits.SendMessages,
              PermissionFlagsBits.ReadMessageHistory,
              PermissionFlagsBits.AttachFiles
            ]
          });
        }

        ticketChannel = await interaction.guild.channels.create({
          name: channelName,
          type: ChannelType.GuildText,
          parent: conf.category_create,
          topic: ticketTopic,
          permissionOverwrites: permissionOverwrites,
          rateLimitPerUser: 3, // 3 gi√¢y slowmode ƒë·ªÉ tr√°nh spam
        });
      } catch (error) {
        console.error('Channel creation error:', error);
        await interaction.editReply({
          embeds: [createErrorEmbed('Kh√¥ng th·ªÉ t·∫°o k√™nh ticket! Vui l√≤ng ki·ªÉm tra quy·ªÅn bot.')]
        });
        return true;
      }

      // C·∫£i ti·∫øn: G·ª≠i tin nh·∫Øn ch√†o m·ª´ng v·ªõi th√¥ng tin ƒë·∫ßy ƒë·ªß h∆°n
      const welcomeEmbed = new EmbedBuilder()
        .setTitle('üé´ Ticket H·ªó Tr·ª£')
        .setDescription([
          `**M√£ Ticket:** \`#${ticketCount}\``,
          `**Ng∆∞·ªùi t·∫°o:** <@${interaction.user.id}>`,
          `**Th·ªùi gian t·∫°o:** <t:${Math.floor(Date.now() / 1000)}:F>`,
          '',
          'üìù **H∆∞·ªõng d·∫´n:**',
          '‚Ä¢ H√£y m√¥ t·∫£ chi ti·∫øt v·∫•n ƒë·ªÅ b·∫°n g·∫∑p ph·∫£i',
          '‚Ä¢ ƒê√≠nh k√®m ·∫£nh/video n·∫øu c·∫ßn thi·∫øt',
          '‚Ä¢ ƒê·ª£i admin ph·∫£n h·ªìi (th∆∞·ªùng trong v√≤ng 24h)',
          '',
          '‚ö†Ô∏è **L∆∞u √Ω:** Kh√¥ng spam ho·∫∑c ping admin kh√¥ng c·∫ßn thi·∫øt',
        ].join('\n'))
        .setColor('#2196f3')
        .setThumbnail(TICKET_ICON)
        .setFooter({ 
          text: `Ticket System ‚Ä¢ ID: ${ticketCount}`, 
          iconURL: TICKET_ICON 
        })
        .setTimestamp();

      const actionRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('ticket_claim')
          .setLabel('üëÆ Claim')
          .setStyle(ButtonStyle.Secondary)
          .setEmoji('üëÆ'),
        new ButtonBuilder()
          .setCustomId('ticket_close')
          .setLabel('ƒê√≥ng Ticket')
          .setStyle(ButtonStyle.Danger)
          .setEmoji('üîí'),
        new ButtonBuilder()
          .setCustomId('ticket_priority')
          .setLabel('∆Øu ti√™n cao')
          .setStyle(ButtonStyle.Primary)
          .setEmoji('‚ö°')
      );

      await ticketChannel.send({
        content: `<@${interaction.user.id}>${pingRole ? ` | <@&${pingRole}>` : ''}`,
        embeds: [welcomeEmbed],
        components: [actionRow],
      });

      // C·∫£i ti·∫øn: G·ª≠i DM v·ªõi error handling
      try {
        const dmEmbed = new EmbedBuilder()
          .setColor('#2196f3')
          .setTitle('üé´ Ticket ƒë√£ ƒë∆∞·ª£c t·∫°o')
          .setThumbnail(TICKET_ICON)
          .setDescription([
            `B·∫°n v·ª´a t·∫°o ticket th√†nh c√¥ng t·∫°i server **${interaction.guild.name}**.`,
            '',
            `**üìã Th√¥ng tin ticket:**`,
            `‚Ä¢ **M√£:** \`#${ticketCount}\``,
            `‚Ä¢ **K√™nh:** <#${ticketChannel.id}>`,
            `‚Ä¢ **Th·ªùi gian:** <t:${Math.floor(Date.now() / 1000)}:R>`,
            '',
            'üí° **M·∫πo:** H√£y m√¥ t·∫£ v·∫•n ƒë·ªÅ m·ªôt c√°ch chi ti·∫øt ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£ nhanh nh·∫•t!',
          ].join('\n'))
          .setFooter({ text: 'B·∫°n s·∫Ω nh·∫≠n ƒë∆∞·ª£c th√¥ng b√°o khi c√≥ ph·∫£n h·ªìi' });

        await interaction.user.send({ embeds: [dmEmbed] });
      } catch (error) {
        // Kh√¥ng l√†m g√¨ n·∫øu kh√¥ng g·ª≠i ƒë∆∞·ª£c DM
      }

      // C·∫£i ti·∫øn: Log v·ªõi th√¥ng tin ƒë·∫ßy ƒë·ªß h∆°n
      if (conf.log_channel) {
        const logChannel = interaction.guild.channels.cache.get(conf.log_channel);
        if (logChannel) {
          const logEmbed = new EmbedBuilder()
            .setTitle('üì© Ticket M·ªõi')
            .setDescription([
              `**K√™nh:** <#${ticketChannel.id}>`,
              `**M√£:** \`#${ticketCount}\``,
              `**Ng∆∞·ªùi t·∫°o:** <@${interaction.user.id}> (${interaction.user.tag})`,
              `**Th·ªùi gian:** <t:${Math.floor(Date.now() / 1000)}:F>`,
            ].join('\n'))
            .setColor('#4CAF50')
            .setThumbnail(interaction.user.displayAvatarURL())
            .setFooter({ text: 'Ticket Log', iconURL: TICKET_ICON })
            .setTimestamp();

          await logChannel.send({ embeds: [logEmbed] }).catch(() => {});
        }
      }

      await interaction.editReply({
        embeds: [createSuccessEmbed(
          `Ticket ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng!\n\n**üìç K√™nh:** <#${ticketChannel.id}>\n**üî¢ M√£:** \`#${ticketCount}\``
        )]
      });
      return true;
    }

    // --- CLAIM TICKET ---
    if (interaction.isButton() && interaction.customId === 'ticket_claim') {
      // Ki·ªÉm tra cooldown
      const cooldown = checkCooldown(interaction.user.id, 'claim_ticket');
      if (cooldown > 0) {
        await interaction.reply({
          embeds: [createErrorEmbed(`‚è≥ Vui l√≤ng ƒë·ª£i ${cooldown} gi√¢y!`)],
          ephemeral: true
        });
        return true;
      }

      const conf = getTicketConfig(db, interaction.guild.id);
      
      // C·∫£i ti·∫øn: Ki·ªÉm tra quy·ªÅn linh ho·∫°t h∆°n
      const hasAdminRole = conf.admin_role && interaction.member.roles.cache.has(conf.admin_role);
      const hasManageChannels = interaction.member.permissions.has(PermissionFlagsBits.ManageChannels);
      
      if (!hasAdminRole && !hasManageChannels) {
        await interaction.reply({
          embeds: [createErrorEmbed('B·∫°n kh√¥ng c√≥ quy·ªÅn claim ticket n√†y!')],
          ephemeral: true
        });
        return true;
      }

      // C·∫£i ti·∫øn: Ki·ªÉm tra xem ƒë√£ ƒë∆∞·ª£c claim ch∆∞a
      const currentPerms = interaction.channel.permissionOverwrites.cache;
      const alreadyClaimed = currentPerms.some(perm => 
        perm.type === 1 && // Member type
        perm.allow.has(PermissionFlagsBits.ManageChannels) &&
        perm.id !== interaction.client.user.id
      );

      if (alreadyClaimed) {
        const claimedBy = currentPerms.find(perm => 
          perm.type === 1 && 
          perm.allow.has(PermissionFlagsBits.ManageChannels) &&
          perm.id !== interaction.client.user.id
        );
        
        await interaction.reply({
          embeds: [new EmbedBuilder()
            .setColor('#FFC107')
            .setTitle('‚ö†Ô∏è Ticket ƒë√£ ƒë∆∞·ª£c claim')
            .setDescription(`Ticket n√†y ƒë√£ ƒë∆∞·ª£c claim b·ªüi <@${claimedBy.id}>`)
          ],
          ephemeral: true
        });
        return true;
      }

      // C·∫≠p nh·∫≠t quy·ªÅn cho ng∆∞·ªùi claim
      await interaction.channel.permissionOverwrites.edit(interaction.user.id, {
        ViewChannel: true,
        SendMessages: true,
        ManageChannels: true,
        ReadMessageHistory: true,
        AttachFiles: true,
      });

      const claimEmbed = new EmbedBuilder()
        .setColor('#43ea3a')
        .setTitle('üëÆ Ticket ƒë√£ ƒë∆∞·ª£c claim')
        .setDescription(`Ticket n√†y ƒë√£ ƒë∆∞·ª£c claim b·ªüi ${interaction.user}!\n\n‚è∞ Th·ªùi gian: <t:${Math.floor(Date.now() / 1000)}:R>`)
        .setThumbnail(interaction.user.displayAvatarURL())
        .setTimestamp();

      await interaction.reply({
        embeds: [claimEmbed],
        ephemeral: false
      });

      // Log claim
      const conf2 = getTicketConfig(db, interaction.guild.id);
      if (conf2.log_channel) {
        const logChannel = interaction.guild.channels.cache.get(conf2.log_channel);
        if (logChannel) {
          const logEmbed = new EmbedBuilder()
            .setTitle('üëÆ Ticket Claimed')
            .setDescription([
              `**Ticket:** <#${interaction.channel.id}>`,
              `**Ng∆∞·ªùi claim:** ${interaction.user} (${interaction.user.tag})`,
              `**Th·ªùi gian:** <t:${Math.floor(Date.now() / 1000)}:F>`,
            ].join('\n'))
            .setColor('#FFC107')
            .setTimestamp();

          await logChannel.send({ embeds: [logEmbed] }).catch(() => {});
        }
      }
      return true;
    }

    // --- ∆ØU TI√äN CAO ---
    if (interaction.isButton() && interaction.customId === 'ticket_priority') {
      const uid = interaction.channel.topic?.match(/UID:(\d{17,})/)?.[1];
      
      if (interaction.user.id !== uid && !interaction.member.permissions.has(PermissionFlagsBits.ManageChannels)) {
        await interaction.reply({
          embeds: [createErrorEmbed('Ch·ªâ ng∆∞·ªùi t·∫°o ticket ho·∫∑c admin m·ªõi c√≥ th·ªÉ ƒë·∫∑t ∆∞u ti√™n cao!')],
          ephemeral: true
        });
        return true;
      }

      // Ki·ªÉm tra xem ƒë√£ ƒë·∫∑t ∆∞u ti√™n ch∆∞a
      if (interaction.channel.name.includes('üî•')) {
        await interaction.reply({
          embeds: [new EmbedBuilder()
            .setColor('#FFC107')
            .setDescription('‚ö†Ô∏è Ticket n√†y ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t ∆∞u ti√™n cao!')
          ],
          ephemeral: true
        });
        return true;
      }

      await interaction.channel.setName(`üî•-${interaction.channel.name}`);
      
      const priorityEmbed = new EmbedBuilder()
        .setColor('#FF5722')
        .setTitle('‚ö° Ticket ∆∞u ti√™n cao')
        .setDescription(`${interaction.user} ƒë√£ ƒë·∫∑t ticket n√†y ·ªü m·ª©c ∆∞u ti√™n cao!\n\nüö® **Admin s·∫Ω ƒë∆∞·ª£c th√¥ng b√°o ngay l·∫≠p t·ª©c.**`)
        .setTimestamp();

      await interaction.reply({
        embeds: [priorityEmbed]
      });

      // Th√¥ng b√°o admin
      const conf = getTicketConfig(db, interaction.guild.id);
      if (conf.admin_role) {
        const adminRole = interaction.guild.roles.cache.get(conf.admin_role);
        if (adminRole) {
          await interaction.followUp({
            content: `üö® <@&${conf.admin_role}> - Ticket ∆∞u ti√™n cao c·∫ßn ƒë∆∞·ª£c x·ª≠ l√Ω!`,
            ephemeral: false
          });
        }
      }

      return true;
    }

    // --- Y√äU C·∫¶U ƒê√ìNG TICKET ---
    if (interaction.isButton() && interaction.customId === 'ticket_close') {
      const uid = interaction.channel.topic?.match(/UID:(\d{17,})/)?.[1];
      const ticketId = interaction.channel.topic?.match(/Ticket:\s*(\d+)/)?.[1] || 'unknown';

      if (interaction.user.id === uid) {
        // User t·∫°o ticket y√™u c·∫ßu ƒë√≥ng
        const embed = new EmbedBuilder()
          .setColor('#4AA4FF')
          .setAuthor({ name: 'ƒê√≥ng Ticket', iconURL: TICKET_ICON })
          .setTitle('üîí Y√™u c·∫ßu ƒë√≥ng ticket')
          .setDescription([
            `Ng∆∞·ªùi d√πng <@${interaction.user.id}> y√™u c·∫ßu ƒë√≥ng ticket n√†y.`,
            '',
            'üëÆ **Admin c·∫ßn x√°c nh·∫≠n ƒë·ªÉ ho√†n t·∫•t vi·ªác ƒë√≥ng ticket.**',
            '',
            '‚è≥ Ticket s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông ƒë√≥ng sau 24h n·∫øu kh√¥ng c√≥ ph·∫£n h·ªìi.',
          ].join('\n'))
          .setFooter({ text: 'Ticket System | C·∫ßn x√°c nh·∫≠n t·ª´ admin', iconURL: TICKET_ICON })
          .setTimestamp();

        const row = new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId(`ticket_admin_confirm_close:${ticketId}`)
            .setLabel('‚úÖ Admin x√°c nh·∫≠n ƒë√≥ng')
            .setStyle(ButtonStyle.Danger)
            .setEmoji('‚úÖ'),
          new ButtonBuilder()
            .setCustomId('ticket_cancel_close')
            .setLabel('üö´ H·ªßy y√™u c·∫ßu')
            .setStyle(ButtonStyle.Secondary)
            .setEmoji('üö´'),
        );

        await interaction.reply({
          embeds: [embed],
          components: [row],
          ephemeral: false
        });

        // T·ª± ƒë·ªông ƒë√≥ng sau 24h n·∫øu kh√¥ng c√≥ ph·∫£n h·ªìi
        setTimeout(async () => {
          try {
            const channel = await interaction.guild.channels.fetch(interaction.channel.id).catch(() => null);
            if (channel && channel.name.includes(ticketId)) {
              await closeTicket(interaction, db, 'T·ª± ƒë·ªông ƒë√≥ng sau 24h kh√¥ng c√≥ ph·∫£n h·ªìi t·ª´ admin');
            }
          } catch (error) {
            // Ignore errors
          }
        }, 24 * 60 * 60 * 1000); // 24 gi·ªù

      } else if (interaction.member.permissions.has(PermissionFlagsBits.ManageChannels)) {
        // Admin ƒë√≥ng tr·ª±c ti·∫øp
        const modal = new ModalBuilder()
          .setCustomId('ticketclose_reason')
          .setTitle('ƒê√≥ng ticket')
          .addComponents(
            new ActionRowBuilder().addComponents(
              new TextInputBuilder()
                .setCustomId('reason')
                .setLabel('L√Ω do ƒë√≥ng ticket')
                .setStyle(TextInputStyle.Paragraph)
                .setPlaceholder('Nh·∫≠p l√Ω do ƒë√≥ng ticket...')
                .setRequired(true)
                .setMaxLength(1000),
            ),
          );
        await interaction.showModal(modal);
      } else {
        await interaction.reply({
          embeds: [createErrorEmbed('B·∫°n kh√¥ng c√≥ quy·ªÅn ƒë√≥ng ticket n√†y!')],
          ephemeral: true
        });
      }
      return true;
    }

    // --- ADMIN X√ÅC NH·∫¨N ƒê√ìNG TICKET ---
    if (interaction.isButton() && interaction.customId.startsWith('ticket_admin_confirm_close:')) {
      if (!interaction.member.permissions.has(PermissionFlagsBits.ManageChannels)) {
        await interaction.reply({
          embeds: [createErrorEmbed('Ch·ªâ admin m·ªõi c√≥ th·ªÉ x√°c nh·∫≠n ƒë√≥ng ticket!')],
          ephemeral: true
        });
        return true;
      }

      const modal = new ModalBuilder()
        .setCustomId('ticketclose_reason')
        .setTitle('X√°c nh·∫≠n ƒë√≥ng ticket')
        .addComponents(
          new ActionRowBuilder().addComponents(
            new TextInputBuilder()
              .setCustomId('reason')
              .setLabel('L√Ω do ƒë√≥ng ticket')
              .setStyle(TextInputStyle.Paragraph)
              .setPlaceholder('Nh·∫≠p l√Ω do ƒë√≥ng ticket...')
              .setRequired(true)
              .setMaxLength(1000),
          ),
        );

      await interaction.showModal(modal);
      return true;
    }

    // --- H·ª¶Y Y√äU C·∫¶U ƒê√ìNG ---
    if (interaction.isButton() && interaction.customId === 'ticket_cancel_close') {
      const uid = interaction.channel.topic?.match(/UID:(\d{17,})/)?.[1];
      
      if (interaction.user.id !== uid && !interaction.member.permissions.has(PermissionFlagsBits.ManageChannels)) {
        await interaction.reply({
          embeds: [createErrorEmbed('B·∫°n kh√¥ng c√≥ quy·ªÅn h·ªßy y√™u c·∫ßu n√†y!')],
          ephemeral: true
        });
        return true;
      }

      await interaction.update({
        embeds: [
          new EmbedBuilder()
            .setColor('#FFC107')
            .setTitle('üö´ ƒê√£ h·ªßy y√™u c·∫ßu')
            .setDescription('Y√™u c·∫ßu ƒë√≥ng ticket ƒë√£ b·ªã h·ªßy.')
            .setTimestamp()
        ],
        components: [],
      });
      return true;
    }

    // --- ƒê√ìNG TICKET (MODAL SUBMIT) ---
    if (interaction.isModalSubmit() && interaction.customId === 'ticketclose_reason') {
      await interaction.deferReply({ ephemeral: true });
      const reason = interaction.fields.getTextInputValue('reason');
      
      if (!reason || reason.trim().length === 0) {
        await interaction.editReply({
          embeds: [createErrorEmbed('Vui l√≤ng nh·∫≠p l√Ω do ƒë√≥ng ticket!')]
        });
        return true;
      }

      await closeTicket(interaction, db, reason.trim());
      await interaction.editReply({
        embeds: [createSuccessEmbed('Ticket ƒë√£ ƒë∆∞·ª£c ƒë√≥ng th√†nh c√¥ng!')]
      });
      return true;
    }

    // --- XEM L·ªäCH S·ª¨ TR√í CHUY·ªÜN ---
    if (interaction.isButton() && interaction.customId.startsWith('ticket_view_history')) {
      await interaction.deferReply({ ephemeral: true });

      const [, ticketId, guildId] = interaction.customId.split(':');
      if (!ticketId || !guildId) {
        await interaction.editReply({
          embeds: [createErrorEmbed('Kh√¥ng th·ªÉ x√°c ƒë·ªãnh th√¥ng tin ticket!')]
        });
        return true;
      }

      // Ki·ªÉm tra quy·ªÅn xem l·ªãch s·ª≠
      let uid = interaction.user.id;
      if (interaction.channel?.topic) {
        const uidMatch = interaction.channel.topic.match(/UID:(\d{17,})/);
        if (uidMatch) uid = uidMatch[1];
      } else {
        try {
          const ticketInfo = db.prepare('SELECT userId FROM ticket_logs WHERE ticketId = ? AND guildId = ?').get(`ticket-${ticketId}`, guildId);
          if (ticketInfo?.userId) uid = ticketInfo.userId;
        } catch (error) {
          // Ignore database errors
        }
      }

      const isOwner = interaction.user.id === uid;
      const isAdmin = interaction.member?.permissions.has(PermissionFlagsBits.ManageChannels);

      if (!isOwner && !isAdmin) {
        await interaction.editReply({
          embeds: [createErrorEmbed('B·∫°n kh√¥ng c√≥ quy·ªÅn xem l·ªãch s·ª≠ ticket n√†y!')]
        });
        return true;
      }

      // T√¨m file log
      const logFilePath = path.join(__dirname, '..', 'ticketlog', `ticket-${ticketId}.md`);
      let logText;
      
      try {
        logText = await fs.readFile(logFilePath, 'utf-8');
      } catch (error) {
        // Th·ª≠ t√¨m trong database
        try {
          const dbLog = db.prepare('SELECT logText FROM ticket_logs WHERE ticketId = ? AND guildId = ?').get(`ticket-${ticketId}`, guildId);
          logText = dbLog?.logText;
        } catch (dbError) {
          // Ignore database errors
        }
      }

      if (!logText) {
        await interaction.editReply({
          embeds: [createErrorEmbed('Kh√¥ng t√¨m th·∫•y l·ªãch s·ª≠ ticket n√†y!')]
        });
        return true;
      }

      const logBuffer = Buffer.from(logText, 'utf-8');
      const fileSize = logBuffer.length;
      
      // Ki·ªÉm tra k√≠ch th∆∞·ªõc file (Discord limit: 8MB)
      if (fileSize > 8 * 1024 * 1024) {
        await interaction.editReply({
          embeds: [createErrorEmbed('File l·ªãch s·ª≠ qu√° l·ªõn ƒë·ªÉ g·ª≠i! Vui l√≤ng li√™n h·ªá admin.')]
        });
        return true;
      }

      await interaction.editReply({
        embeds: [
          new EmbedBuilder()
            .setColor('#2196f3')
            .setTitle('üìú L·ªãch s·ª≠ ticket')
            .setDescription(`L·ªãch s·ª≠ chi ti·∫øt c·ªßa ticket #${ticketId}`)
            .setFooter({ text: `K√≠ch th∆∞·ªõc: ${(fileSize / 1024).toFixed(2)} KB` })
        ],
        files: [{ 
          attachment: logBuffer, 
          name: `ticket-${ticketId}-history.md` 
        }],
      });
      return true;
    }

    return false;
  } catch (error) {
    console.error('Ticket interaction error:', error);
    
    const errorEmbed = createErrorEmbed('ƒê√£ x·∫£y ra l·ªói h·ªá th·ªëng! Vui l√≤ng th·ª≠ l·∫°i sau.');
    
    try {
      if (!interaction.replied && !interaction.deferred) {
        await interaction.reply({
          embeds: [errorEmbed],
          ephemeral: true
        });
      } else if (interaction.deferred) {
        await interaction.editReply({
          embeds: [errorEmbed]
        });
      }
    } catch (replyError) {
      console.error('Failed to send error message:', replyError);
    }
    
    return true;
  }
}

// --- H√ÄM ƒê√ìNG TICKET (C·∫¢I TI·∫æN) ---
async function closeTicket(interaction, db, reason) {
  try {
    let ticketId = interaction.channel.topic?.match(/Ticket:\s*(\d+)/)?.[1];
    const uid = interaction.channel.topic?.match(/UID:(\d{17,})/)?.[1];
    const createdTime = interaction.channel.topic?.match(/Created:\s*(\d+)/)?.[1];

    if (!ticketId) {
      const conf = getTicketConfig(db, interaction.guild.id);
      ticketId = conf?.ticket_count?.toString() || 'unknown';
    }

    // C·∫£i ti·∫øn: L∆∞u log v·ªõi metadata ƒë·∫ßy ƒë·ªß
    const messages = await fetchAllMessages(interaction.channel);
    const logText = generateTicketLog(messages, {
      ticketId,
      userId: uid,
      guildId: interaction.guild.id,
      channelId: interaction.channel.id,
      createdAt: createdTime ? new Date(parseInt(createdTime)) : null,
      closedAt: new Date(),
      closedBy: interaction.user.id,
      reason: reason
    });

    // L∆∞u v√†o database v√† file
    await saveTicketLog(db, ticketId, interaction.guild.id, uid, logText);

    // Th√¥ng b√°o ƒë√≥ng ticket
    const closeEmbed = new EmbedBuilder()
      .setColor('#E74C3C')
      .setTitle('üîí Ticket ƒë√£ ƒë√≥ng')
      .setDescription([
        `**M√£ ticket:** \`#${ticketId}\``,
        `**ƒê√≥ng b·ªüi:** ${interaction.user}`,
        `**L√Ω do:** ${reason}`,
        `**Th·ªùi gian:** <t:${Math.floor(Date.now() / 1000)}:F>`,
      ].join('\n'))
      .setThumbnail(TICKET_ICON)
      .setTimestamp();

    const historyButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`ticket_view_history:${ticketId}:${interaction.guild.id}`)
        .setLabel('üìú Xem l·ªãch s·ª≠')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üìú'),
      new ButtonBuilder()
        .setCustomId('ticket_closed')
        .setLabel('Ticket ƒë√£ ƒë√≥ng')
        .setStyle(ButtonStyle.Secondary)
        .setDisabled(true)
        .setEmoji('üîí'),
    );

    await interaction.channel.send({
      embeds: [closeEmbed],
      components: [historyButton],
    });

    // G·ª≠i DM cho user
    if (uid) {
      try {
        const member = await interaction.guild.members.fetch(uid).catch(() => null);
        if (member) {
          const dmEmbed = new EmbedBuilder()
            .setColor('#E74C3C')
            .setTitle('üîí Ticket ƒë√£ ƒë∆∞·ª£c ƒë√≥ng')
            .setThumbnail(TICKET_ICON)
            .setDescription([
              `üé´ Ticket c·ªßa b·∫°n t·∫°i **${interaction.guild.name}** ƒë√£ ƒë∆∞·ª£c ƒë√≥ng.`,
              '',
              `**üìã Th√¥ng tin:**`,
              `‚Ä¢ **M√£:** \`#${ticketId}\``,
              `‚Ä¢ **L√Ω do:** ${reason}`,
              `‚Ä¢ **Th·ªùi gian:** <t:${Math.floor(Date.now() / 1000)}:R>`,
              '',
              'üí° N·∫øu v·∫´n c·∫ßn h·ªó tr·ª£, h√£y t·∫°o ticket m·ªõi!',
            ].join('\n'))
            .setTimestamp();

          await member.send({
            embeds: [dmEmbed],
            components: [
              new ActionRowBuilder().addComponents(
                new ButtonBuilder()
                  .setCustomId(`ticket_view_history:${ticketId}:${interaction.guild.id}`)
                  .setLabel('üìú Xem l·ªãch s·ª≠')
                  .setStyle(ButtonStyle.Primary),
              ),
            ],
          });
        }
      } catch (error) {
        // Ignore DM errors
      }
    }

    // Log v√†o channel log
    const conf = getTicketConfig(db, interaction.guild.id);
    if (conf.log_channel) {
      const logChannel = interaction.guild.channels.cache.get(conf.log_channel);
      if (logChannel) {
        const adminLogEmbed = new EmbedBuilder()
          .setTitle('üì¶ Ticket ƒë√£ ƒë√≥ng')
          .setDescription([
            `**K√™nh:** <#${interaction.channel.id}>`,
            `**M√£:** \`#${ticketId}\``,
            `**User:** <@${uid || 'unknown'}>`,
            `**ƒê√≥ng b·ªüi:** ${interaction.user} (${interaction.user.tag})`,
            `**L√Ω do:** ${reason}`,
            `**S·ªë tin nh·∫Øn:** ${messages.length}`,
          ].join('\n'))
          .setColor('#E74C3C')
          .setFooter({ text: 'Ticket Log', iconURL: TICKET_ICON })
          .setTimestamp();

        await logChannel.send({
          embeds: [adminLogEmbed],
          components: [
            new ActionRowBuilder().addComponents(
              new ButtonBuilder()
                .setCustomId(`ticket_view_history:${ticketId}:${interaction.guild.id}`)
                .setLabel('üìú Xem l·ªãch s·ª≠')
                .setStyle(ButtonStyle.Primary),
            ),
          ],
        }).catch(() => {});
      }
    }

    // Di chuy·ªÉn ticket sang danh m·ª•c ƒë√≥ng n·∫øu c√≥
    if (conf.category_close) {
      try {
        await interaction.channel.setParent(conf.category_close);
        
        const overwrites = [
          { id: interaction.guild.roles.everyone, deny: [PermissionFlagsBits.ViewChannel] },
          { id: interaction.client.user.id, allow: [PermissionFlagsBits.ViewChannel] }
        ];
        
        if (conf.admin_role && interaction.guild.roles.cache.has(conf.admin_role)) {
          overwrites.push({ 
            id: conf.admin_role, 
            allow: [PermissionFlagsBits.ViewChannel] 
          });
        }
        
        await interaction.channel.permissionOverwrites.set(overwrites);
        
        // T·ª± ƒë·ªông x√≥a sau 24 gi·ªù
        setTimeout(async () => {
          try {
            const channel = await interaction.guild.channels.fetch(interaction.channel.id).catch(() => null);
            if (channel) {
              await channel.delete();
              
              // Log vi·ªác x√≥a
              if (conf.log_channel) {
                const logCh = interaction.guild.channels.cache.get(conf.log_channel);
                if (logCh) {
                  await logCh.send({
                    embeds: [
                      new EmbedBuilder()
                        .setTitle('üóëÔ∏è Ticket ƒë√£ x√≥a')
                        .setDescription(`Ticket \`#${ticketId}\` ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông x√≥a sau 24 gi·ªù.`)
                        .setColor('#95A5A6')
                        .setTimestamp()
                        .setFooter({ text: 'Auto Delete', iconURL: TICKET_ICON }),
                    ],
                  }).catch(() => {});
                }
              }
            }
          } catch (error) {
            console.error('Auto delete error:', error);
          }
        }, 24 * 60 * 60 * 1000); // 24 gi·ªù
        
      } catch (error) {
        console.error('Move to close category error:', error);
      }
    }

    // V√¥ hi·ªáu h√≥a c√°c button trong ticket
    try {
      const messages = await interaction.channel.messages.fetch({ limit: 50 });
      for (const message of messages.values()) {
        if (message.author.id === interaction.client.user.id && message.components?.length > 0) {
          const hasTicketButtons = message.components.some(row => 
            row.components.some(component => 
              component.customId?.includes('ticket_') && 
              !component.customId.includes('ticket_view_history') &&
              !component.customId.includes('ticket_closed')
            )
          );
          
          if (hasTicketButtons) {
            await message.edit({
              components: [historyButton]
            }).catch(() => {});
          }
        }
      }
    } catch (error) {
      console.error('Disable buttons error:', error);
    }

  } catch (error) {
    console.error('Close ticket error:', error);
    throw error;
  }
}

// --- H√ÄM T·∫†O LOG TICKET ---
function generateTicketLog(messages, metadata) {
  const header = [
    `# üé´ Ticket Log #${metadata.ticketId}`,
    '',
    `**üìã Th√¥ng tin ticket:**`,
    `- **M√£ ticket:** #${metadata.ticketId}`,
    `- **Server ID:** ${metadata.guildId}`,
    `- **Channel ID:** ${metadata.channelId}`,
    `- **User ID:** ${metadata.userId}`,
    `- **Th·ªùi gian t·∫°o:** ${metadata.createdAt ? metadata.createdAt.toLocaleString('vi-VN') : 'Kh√¥ng x√°c ƒë·ªãnh'}`,
    `- **Th·ªùi gian ƒë√≥ng:** ${metadata.closedAt.toLocaleString('vi-VN')}`,
    `- **ƒê√≥ng b·ªüi:** <@${metadata.closedBy}>`,
    `- **L√Ω do ƒë√≥ng:** ${metadata.reason}`,
    `- **T·ªïng s·ªë tin nh·∫Øn:** ${messages.length}`,
    '',
    '---',
    '',
    '## üí¨ L·ªãch s·ª≠ tr√≤ chuy·ªán:',
    ''
  ].join('\n');

  const messageLog = messages
    .sort((a, b) => a.createdTimestamp - b.createdTimestamp)
    .map(message => {
      const time = new Date(message.createdTimestamp).toLocaleString('vi-VN');
      let icon = 'üí¨';
      
      if (message.author.bot) icon = 'ü§ñ';
      if (message.system) icon = '‚öôÔ∏è';
      if (message.type === 7) icon = 'üëã'; // Welcome message
      
      let content = message.content || '*[Tin nh·∫Øn tr·ªëng]*';
      
      // X·ª≠ l√Ω attachments
      if (message.attachments && message.attachments.size > 0) {
        const attachments = [...message.attachments.values()]
          .map(att => `[üìé ${att.name}](${att.url})`)
          .join(', ');
        content += `\n*ƒê√≠nh k√®m: ${attachments}*`;
      }
      
      // X·ª≠ l√Ω embeds
      if (message.embeds && message.embeds.length > 0) {
        content += `\n*[üìã Embed: ${message.embeds.length} embed(s)]*`;
      }
      
      // X·ª≠ l√Ω reactions
      if (message.reactions && message.reactions.cache.size > 0) {
        const reactions = [...message.reactions.cache.values()]
          .map(reaction => `${reaction.emoji} ${reaction.count}`)
          .join(' ');
        content += `\n*Reactions: ${reactions}*`;
      }
      
      return [
        `### ${icon} ${message.author.tag} - ${time}`,
        content,
        ''
      ].join('\n');
    })
    .join('\n');

  const footer = [
    '---',
    '',
    `*üìä Log ƒë∆∞·ª£c t·∫°o t·ª± ƒë·ªông b·ªüi Ticket System v√†o ${new Date().toLocaleString('vi-VN')}*`
  ].join('\n');

  return [header, messageLog, footer].join('\n');
}

// --- H√ÄM L∆ØU LOG ---
async function saveTicketLog(db, ticketId, guildId, userId, logText) {
  // L∆∞u v√†o database
  try {
    const hasUserIdColumn = db.prepare('PRAGMA table_info(ticket_logs)').all()
      .some(col => col.name === 'userId');
    
    if (hasUserIdColumn) {
      db.prepare(`
        INSERT INTO ticket_logs (ticketId, guildId, userId, logText, createdAt) 
        VALUES (?, ?, ?, ?, ?) 
        ON CONFLICT(ticketId, guildId) DO UPDATE SET 
          userId = ?, logText = ?, updatedAt = ?
      `).run(
        `ticket-${ticketId}`, guildId, userId, logText, Date.now(),
        userId, logText, Date.now()
      );
    } else {
      db.prepare(`
        INSERT INTO ticket_logs (ticketId, guildId, logText) 
        VALUES (?, ?, ?) 
        ON CONFLICT(ticketId, guildId) DO UPDATE SET logText = ?
      `).run(`ticket-${ticketId}`, guildId, logText, logText);
    }
  } catch (error) {
    console.error('Database save error:', error);
  }

  // L∆∞u v√†o file
  try {
    const logDir = path.join(__dirname, '..', 'ticketlog');
    await fs.mkdir(logDir, { recursive: true });
    const logFilePath = path.join(logDir, `ticket-${ticketId}.md`);
    await fs.writeFile(logFilePath, logText, 'utf-8');
  } catch (error) {
    console.error('File save error:', error);
  }
}

// --- H√ÄM L·∫§Y T·∫§T C·∫¢ TIN NH·∫ÆN (C·∫¢I TI·∫æN) ---
async function fetchAllMessages(channel, limit = 10000) {
  let messages = [];
  let lastId;
  let fetchCount = 0;
  const maxFetches = Math.ceil(limit / 100);
  
  try {
    while (fetchCount < maxFetches) {
      const options = { limit: Math.min(100, limit - messages.length) };
      if (lastId) options.before = lastId;
      
      const fetched = await channel.messages.fetch(options);
      if (!fetched || fetched.size === 0) break;
      
      const fetchedArray = [...fetched.values()];
      messages = [...fetchedArray, ...messages];
      lastId = fetched.first()?.id;
      fetchCount++;
      
      if (fetched.size < 100 || messages.length >= limit) break;
      
      // Tr√°nh rate limit
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  } catch (error) {
    console.error('Fetch messages error:', error);
  }
  
  return messages.slice(0, limit);
}

// --- CLEANUP FUNCTIONS ---
function cleanupCaches() {
  const now = Date.now();
  
  // Cleanup config cache
  for (const [key, value] of configCache.entries()) {
    if (now - value.timestamp > CACHE_TTL) {
      configCache.delete(key);
    }
  }
  
  // Cleanup cooldowns
  for (const [key, timestamp] of ticketCooldowns.entries()) {
    if (now - timestamp > COOLDOWN_TIME) {
      ticketCooldowns.delete(key);
    }
  }
}

// Cleanup m·ªói 5 ph√∫t
setInterval(cleanupCaches, 5 * 60 * 1000);

module.exports = { 
  handleTicketInteraction,
  cleanupCaches,
  getTicketConfig,
  clearConfigCache
};